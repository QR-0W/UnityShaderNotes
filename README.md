# Unity Shader入门精要简洁阅读记录

## 计算机图形学第一定律：如果它看起来是对的，那它就是对的。

## 电子版资料将不会上传。有能力的话请各位支持正版。

## 基础篇

### 第二章 渲染流水线

- 概念流水线

	- 应用阶段-几何阶段-光栅化阶段

- CPU与GPU之间的通信

	- 把数据加载到显存中
	- 设置渲染状态
	- 调用DrawCall

- GPU流水线

	- 顶点数据
	- 顶点着色器

		- 顶点着色器是流水线的第一个阶段，需要完成坐标变换和逐顶点光照
		- 坐标变换：就是将顶点坐标转换到齐次裁剪坐标系下

	- 曲面细分着色器
	- 几何着色器
	- 裁剪
	- 屏幕映射

		- 屏幕映射将坐标映射到屏幕坐标系下

	- 三角形设置

		- 计算三角网格表示的数据

	- 三角形遍历

		- 三角形遍历 (Triangle Traversal) 阶段将会检查每个像素是否被 一 个三角网格所覆盖。如果被覆盖的话，就会生成一个 片元 (fragment) 。而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为 扫描变换 (Scan Conversion) 。

	- 片元着色器

		- 片元着色器 (Fragment Shader) 是另 一 个非常重要的可编程着色器阶段。在 DirectX 中，片元着色器被称为 像素着色器 (Pixel Shader) , 但片元着色器是 一 个更合适的名字，因为此时的片元并不是一个真正意义上的像素。

	- 逐片元操作

		- 片元通过模板测试、深度测试、混合，输出到颜色缓冲区中

	- 屏幕图像

- 什么是DrawCall

	- 由于大部分情况下，GPU执行的速度很快，实际上在Draw Call中拖后腿的反而是CPU
	- 当Draw Call多的时候，每次Draw Call都需要让CPU来准备数据，因此会耗费很多时间
	- 通过批处理、避免使用大量小网格、避免使用过多材质，可以有效的减少Draw Call

### 第三章 Unity Shader基础

- Unity Shader概述
- Shader Lab

	- Shader Lab是unity提供的一个更高层级的渲染抽象层
	- ShaderLab定义了一个材质所需要的所有东西，而不仅仅是着色器代码
	- Shader "ShaderName " {
Properties {
／／属性
}
SubShader {
／／显卡 A 使用的子若色器
}
SubShader {
／／显卡 B 使用的子着色器
}
Fallback "Vertex Lit "

- Unity Shader的结构

	- shader名字

		- 通过在第一行使用这样的语句来命名自己的shader：Shader "Custom/MyShader "{  }

	- properties

		- Properties 语义块中包含了 一系列属性 (property)，这些属性将会出现在材质面板中。

	- SubShader

		- 每一个UnityShader文件可以包含多个SubShader语义块，但最少要有一个。 
		- 当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义块， 然后选择第一个能够在目标平台上运行的SubShader。 如果都不支持的话， Unity就会使用Fallback语义指定的Unity Shader。
		- SubShader通常包含的定义如下
SubShader { 
／／可选的
[Tags] 
／／可选的
[RenderSetup) 
Pass { 
// Other Passes 
}

			- RenderSetup是状态
			- Tags是标签
			- Pass语义块

	- Fallback

- Unity Shader的形式

	- 表面着色器

		- 表面着色器定义在SubShader语义块中

	- 顶点、片元着色器

		- 被定义在Pass中

### 第四章 学习Shader所需的数学基础

- 笛卡尔坐标系

	- 二维笛卡尔坐标系
	- 三维笛卡尔坐标系

- 点和矢量
- 矩阵
- 坐标空间
- MVPC矩阵
- 法线变换
- Unity内置的变量

## 初级篇

### 第五章 开始Unity Shader学习之路

- 顶点、片元着色器的基本结构
- 模型数据从哪里来
- 顶点着色器怎么和片元着色器之间通信
- CG/HLSL语义
- Frame Debugger
- 渲染平台的差异
- Shader规范化

### 第六章 Unity中的基础光照

- 光源、吸收和散射
- BRDF光照模型
- 标准光照模型

	- 自发光emissive：当给定一个方向时，一个表面本身会向该方向发射多少辐射量
	- 高光反射specular：当光线从光源照射到表面的时候，会在完全镜面方向散射多少辐射量

		- 高光反射利用blinn-phong模型计算

	- 漫反射diffuse：当光线从光源照射到表面的时候，会向每个方向散射多少辐射量

		- 漫反射光照符合兰伯特定律

	- 环境光ambient：用于描述其他的间接光照

		- 在标准光照模型中，使用环境光来模拟间接光照

### 第七章 基础纹理

- 纹理映射
- 单张纹理

	- Mipmap
	- 滤波

- 凹凸映射

	- 高度纹理Height Map

		- 模拟表面位移

	- 法线纹理Normal Map

		- 直接存储表面法线
		- 实际会使用切线空间法线纹理

- 渐变纹理

	- 使用渐变纹理控制漫反射

- 遮罩纹理

	- 利用遮罩纹理保护某些区域

### 第八章 透明效果

- 渲染顺序与深度缓冲区
- Render Queue
- 透明度测试

	- 只要一个片元的透明度不满足条件，那么它对应的片元就会被舍弃，被舍弃的片元将不会再进行任何处理，也不会对颜色缓冲造成影响。
	- 透明度测试的效果很极端，要不是完全透明，要不就是不透明。

- 透明度混合

	- 这种方法可以得到真正的半透明效果。它会使用片元的透明度作为混合因子，与已经存储在颜色缓冲中的颜色值进行混合，得到新的颜色。
	- 透明度混合需要关闭深度写入。这是因为当模型出现复杂的遮挡关系的时候，会出现排序错误而导致的错误透明效果。

- 开启深度写入的半透明效果

	- 使用两个Pass来渲染模型

		- 第一个Pass开启深度写入，但是不输出颜色，仅仅将模型的深度信息写入深度缓冲中
		- 第二个Pass进行正常的透明度混合，这个时候因为上一个Pass已经得到了正确的深度信息，所以可以正确渲染
		- 缺点是会影响性能

- ShaderLab的混合命令
- 透明度的双面渲染

## 中级篇

### 第九章 更复杂的光照

- Unity的渲染路径

	- 渲染路径决定了光照是如何应用到Shader中的
	- 前向渲染路径

		- 前向渲染路径是最常用的渲染路径
		- 前向渲染路径的原理

			- 渲染该对象的渲染图元，计算颜色与深度缓冲区的信息，利用深度缓冲区决定一个片元是否可见，如果可见就更新颜色缓冲区中的颜色值。
			- 对于每个逐像素光源，都需要进行一次流程。如果一个物体在多个逐像素光源的影响区域内，就需要多个Pass。

		- Unity中的前向渲染

			- 在Unity中，有三种处理光照的方式：逐顶点处理、逐像素处理、球谐函数处理。
决定一个光源使用哪种处理模式取决于它的类型和是否重要。

		- 内置的光照变量和函数

	- 顶点照明渲染路径
	- 延迟渲染路径

- Unity的光源类型

	- 光源类型有什么影响

		- 光源的位置、方向
		- 光源的颜色、强度、衰减

- Unity的光照衰减
- Unity的阴影

	- 一个物体想要接收阴影，就必须在Shader中对阴影映射纹理进行采样，把采样结果和光照相乘产生阴影。
	- 一个物体想要投射阴影，就必须把该物体加入光源的阴影映射纹理的计算中，从而让其他物体对阴影映射纹理采样中得到该物体的信息。

### 第十章 高级纹理

- 立方体纹理

	- 天空盒
	- 用于环境映射的立方体纹理
	- 反射

		- 模拟反射效果需要通过入射光线的方向和表面法线方向来计算反射方向，然后对反射方向对立方体纹理采样即可。

	- 折射

		- 准确的模拟需要计算两次折射。但是在实时渲染中，常常只进行模拟第一次折射。

	- 菲涅尔反射

		- 即当光线照射到物体表面上时，一部分发生反射，一部分进入物体内部，发生折射或散射

- 纹理渲染

	- 镜面效果

		- 使用渲染纹理作为输入属性，并且把该渲染纹理在水平方向上进行翻转

	- 玻璃效果

		- 当我们在 Shader 中定义了一个 GrabPass 后， Unity 会把当前屏幕的图像绘制在一张纹理中 ，以便我们在后续的 Pass 中访问它我们通常会使用 GrabPass 来实现诸如玻璃等透明材质的模拟。
		- 与使用简单的透明混合不同，使用GrabPass 可以让我们对该物体后面的图像进行更复杂的处理，例如使用法线来模拟折射效果，而不再是简单的和原屏幕颜色进行混合。

- 程序纹理

### 第十一章 让画面动起来

- Unity Shader中内置的时间变量
- 纹理动画

	- 序列帧动画
	- 滚动的背景

- 顶点动画

	- 流动的河流
	- 广告牌Billboard
	- 如果需要阴影的话还需要自定义ShadowCaster Pass，否则阴影无法正常显示，因为这个Pass没有相关的顶点动画

## 高级篇

### 第十二章 屏幕后处理效果

- 屏幕后处理

	- 在渲染完整个场景之后，再对这个图像进行一系列操作，实现各种屏幕特效。
	- 想要实现屏幕后处理的基础在于获得渲染之后的屏幕图像。
	- 屏幕后处理实际上是在场景中绘制了一个与屏幕相同宽高的四边形面片，为了防止它对其他物体产生影响，因此需要关闭深度写入。

- 调整屏幕的亮度、饱和度和对比度
- 边缘检测
- 高斯模糊
- Bloom效果
- 运动模糊

	- 累积缓存
	- 速度缓存

### 第十三章 使用深度和法线纹理

- 获取深度和法线纹理

	- 深度纹理实际上是一张渲染纹理，只不过里面存储的是深度值
	- 在Unity中，深度纹理可以直接获取

- 全局雾效

### 第十四章 非真实感渲染

- 卡通风格的渲染

	- 渲染轮廓线
	- 添加高光

- 素描风格的渲染

### 第十五章 使用噪声

- 消融
- 非均匀全局雾效

### 第十六章 Unity中的渲染优化技术

- 影响性能的因素

	- CPU

		- 过多的Draw Call
		- 复杂的脚本
		- 物理模拟

	- GPU

		- 顶点处理

			- 过多顶点
			- 过多逐顶点计算

		- 片元处理

			- 过多的片元（高分辨率或者过多overdraw）
			- 过多逐片元计算

	- 贷款

		- 使用了未压缩的纹理
		- 分辨率过高的帧缓存

- 减少Draw Call数目

	- 使用同一个材质的物体可以使用Batch批处理

		- 动态批处理

			- 动态批处理的限制较多

		- 静态批处理

			- 把静态批处理的模型全部合并，但是他们在运行时不能被移动

	- 共享材质

- 减少需要处理的顶点数目

	- 优化几何体

		- 尽可能减少三角面片数量

	- LOD技术
	- 遮挡剔除Occlusion Culling

- 减少需要处理的片元数目

	- 控制绘制顺序
	- 检查半透明对象的Overdraw
	- 减少实时光照和阴影

- 节省带宽

	- 减少纹理大小
	- 屏幕分辨率缩放

- 减少计算复杂度

	- Shader的LOD技术

## 扩展篇

### 第十七章 Unity的表面着色器探秘

- Surface Shader可以轻松实现光照模型，甚至不需要和任何光照变量打交道
- 表面着色器中最重要的部分是两个结构体和一个编译指令

	- 编译指令最重要的作用就是指明表面着色器使用的表面函数和光照函数

		- 表面函数

			- 表面属性就定义好了反射率、光滑率等

		- 光照函数
		- 可选参数

	- Input结构体

		- Input结构体包含了许多表面属性的数据来源

	- SurfaceOutput结构体

		- 这个结构体里的变量都是提前申明好的

- Unity背后做了什么
- Surface Shader的缺点

### 第十八章 基于物理的渲染

- PBS的理论与数学基础

	- 光是什么

		- 在光的传播过程中，影响光的一个重要特性是材质的折射率
		- 有多少光会被反射是通过菲涅尔公式来描述的
		- 非金属材质会同时表现出吸收和散射两种现象，被散射出去的光被称为次表面散射光

	- 双向反射分布函数BRDF

		- 辐射率是单位面积、单位方向上光源的辐射通量，被认为是单一光线的亮度和颜色评估
		- 利用基于表面的入射光线的入射辐射率计算出射辐射率的过程，也被称作为着色的过程
		- 想要得出出射辐射率，需要知道物体表面一点是如何和光进行交互的。这个过程可以利用BRDF来分析

	- 漫反射项
	- 高光反射项

### 第十九章 Unity5更新了什么

### 第二十章 还有更多内容吗

